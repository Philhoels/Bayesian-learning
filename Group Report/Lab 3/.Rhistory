sd = sqrt(Gibbs_sampling2$sigma2[dim(Gibbs_sampling2)[1]]))
# the plot
ggplot(data = as.data.frame(plot_data_q1c2), aes(x = plot_data_q1c2)) +
geom_histogram(aes(y=..density..),
colour="black",
fill="white",
bins=30)+
geom_line(aes(x = plot_data_q1c2, y=..density..),alpha=.2, colour = "blue", size=1) +
xlab("values")
# plot data
plot_data_q1c2 <-  rnorm(n = nDraws, mean = Gibbs_sampling2$mu[dim(Gibbs_sampling2)[1]],
sd = sqrt(Gibbs_sampling2$sigma2[dim(Gibbs_sampling2)[1]]))
# the plot
ggplot(data = as.data.frame(plot_data_q1c2), aes(x = plot_data_q1c2)) +
geom_histogram(aes(y=..density..),
colour="black",
fill="white",
bins=30)+
geom_density(alpha=.2, colour = "blue", size=1) +
xlab("values")
hist(x)
hist(x,breaks=30)
ggplot(data = rainfall, aes(x = precipitation)) +
geom_histogram(aes(y=..density..),
colour="black",
fill="white",
bins=20)
ggplot(data = rainfall, aes(x = precipitation)) +
geom_histogram(aes(y=..density..),
colour="black",
fill="white",
bins=20)
head(as.data.frame(x))
ggplot(data = x, aes(x = V1)) +
geom_histogram(aes(y=..density..),
colour="black",
fill="white",
bins=30)
ggplot(data = as.data.frame(x), aes(x = V1)) +
geom_histogram(aes(y=..density..),
colour="black",
fill="white",
bins=30)
hist(x, breaks = 50, freq = FALSE, xlim = c(xGridMin,xGridMax), main = "Final fitted density")
lines(xGrid, mixDensMean, type = "l", lwd = 2, lty = 4, col = "red")
lines(xGrid, dnorm(xGrid, mean = mean(x), sd = apply(x,2,sd)), type = "l", lwd = 2, col = "blue")
legend("topright", box.lty = 1, legend = c("Data histogram","Mixture density","Normal density"), col=c("black","red","blue"), lwd = 2)
hist(x, breaks = 10, freq = FALSE, xlim = c(xGridMin,xGridMax), main = "Final fitted density")
lines(xGrid, mixDensMean, type = "l", lwd = 2, lty = 4, col = "red")
lines(xGrid, dnorm(xGrid, mean = mean(x), sd = apply(x,2,sd)), type = "l", lwd = 2, col = "blue")
legend("topright", box.lty = 1, legend = c("Data histogram","Mixture density","Normal density"), col=c("black","red","blue"), lwd = 2)
hist(x, breaks = 20, freq = FALSE, xlim = c(xGridMin,xGridMax), main = "Final fitted density")
lines(xGrid, mixDensMean, type = "l", lwd = 2, lty = 4, col = "red")
lines(xGrid, dnorm(xGrid, mean = mean(x), sd = apply(x,2,sd)), type = "l", lwd = 2, col = "blue")
legend("topright", box.lty = 1, legend = c("Data histogram","Mixture density","Normal density"), col=c("black","red","blue"), lwd = 2)
hist(x, breaks = 15, freq = FALSE, xlim = c(xGridMin,xGridMax), main = "Final fitted density")
lines(xGrid, mixDensMean, type = "l", lwd = 2, lty = 4, col = "red")
lines(xGrid, dnorm(xGrid, mean = mean(x), sd = apply(x,2,sd)), type = "l", lwd = 2, col = "blue")
legend("topright", box.lty = 1, legend = c("Data histogram","Mixture density","Normal density"), col=c("black","red","blue"), lwd = 2)
hist(x, breaks = 5, freq = FALSE, xlim = c(xGridMin,xGridMax), main = "Final fitted density")
lines(xGrid, mixDensMean, type = "l", lwd = 2, lty = 4, col = "red")
lines(xGrid, dnorm(xGrid, mean = mean(x), sd = apply(x,2,sd)), type = "l", lwd = 2, col = "blue")
legend("topright", box.lty = 1, legend = c("Data histogram","Mixture density","Normal density"), col=c("black","red","blue"), lwd = 2)
hist(x, breaks = 20, freq = FALSE, xlim = c(xGridMin,xGridMax), main = "Final fitted density")
lines(xGrid, mixDensMean, type = "l", lwd = 2, lty = 4, col = "red")
lines(xGrid, dnorm(xGrid, mean = mean(x), sd = apply(x,2,sd)), type = "l", lwd = 2, col = "blue")
legend("topright", box.lty = 1, legend = c("Data histogram","Mixture density","Normal density"), col=c("black","red","blue"), lwd = 2)
ggplot(data = as.data.frame(x), aes(x = V1)) +
geom_histogram(aes(y=..density..),
colour="black",
fill="white",
bins=20)
# make the plot above with ggplot
ggplot(data = as.data.frame(x), aes(x = x)) +
geom_histogram(aes(y=..density..),
colour="black",
fill="white",
bins=20) +
geom_line(data = data.frame(x = xGrid, y = mixDensMean), linetype = "dotdash",
aes(x = xGrid, y = mixDensMean),size=1.5,color="Red")
# make the plot above with ggplot
ggplot(data = as.data.frame(x), aes(x = x)) +
geom_histogram(aes(y=..density..),
colour="black",
fill="white",
bins=25) +
geom_line(data = data.frame(x = xGrid, y = mixDensMean), linetype = "dotdash",
aes(x = xGrid, y = mixDensMean),size=1.5,color="Red")
# make the plot above with ggplot
ggplot(data = as.data.frame(x), aes(x = x)) +
geom_histogram(aes(y=..density..),
colour="black",
fill="white",
bins=40) +
geom_line(data = data.frame(x = xGrid, y = mixDensMean), linetype = "dotdash",
aes(x = xGrid, y = mixDensMean),size=1.5,color="Red")
rm(list = ls())
data <- read.table("eBayNumberOfBidderData.dat", head = TRUE)
mdl.2a <- glm(nBids ~ 0 + ., data = data)
summary(mdl.2a)
dim(data)
rm(list = ls())
data <- read.table("eBayNumberOfBidderData.dat", head = TRUE)
mdl.2a <- glm(nBids ~ ., data = data[,2:10], family = "possion")
rm(list = ls())
data <- read.table("eBayNumberOfBidderData.dat", head = TRUE)
mdl.2a <- glm(nBids ~ ., data = data[,2:10], family = possion)
rm(list = ls())
data <- read.table("eBayNumberOfBidderData.dat", head = TRUE)
mdl.2a <- glm(nBids ~ ., data = data[,2:10],  family = poisson)
rm(list = ls())
data <- read.table("eBayNumberOfBidderData.dat", head = TRUE)
mdl.2a <- glm(nBids ~ ., data = data[,2:10])
head(data)
rm(list = ls())
data <- read.table("eBayNumberOfBidderData.dat", head = TRUE)
mdl.2a <- glm(nBids ~ ., data = data[-2])
summary(mdl.2a)
knitr::opts_chunk$set(echo = TRUE)
### -------------- Lab 3 ### --------------  ###
### --------------  a)
# load and prep data
data <- read.table("eBayNumberOfBidderData.dat", header = TRUE)
y <- data$nBids
n <- nrow(data)
# for the R glm function, we do not need a intercept in the data - glm does create it??s own
data_noIntercept <- data[,-2]
colnames_vec <- colnames(data_noIntercept)
# Poisson regression model
Poisson_rm <- glm(formula = nBids ~ .,
data = data_noIntercept,
family = poisson)
summary(Poisson_rm)
rm(list = ls())
data <- read.table("eBayNumberOfBidderData.dat", head = TRUE)
mdl.2a <- glm(nBids ~ ., data = data[-2], family = poisson)
summary(mdl.2a)
rm(list = ls())
data <- read.table("eBayNumberOfBidderData.dat", head = TRUE)
mdl.2a <- glm(nBids ~ ., data = data[-2], family = poisson)
summary(mdl.2a)
rm(list = ls())
data <- read.table("eBayNumberOfBidderData.dat", head = TRUE)
mdl.2a <- glm(nBids ~ ., data = data[-2], family = poisson)
summary(mdl.2a)
y <- data[,1]
X <- as.matrix(data[,2:10])
# rename X columns
covNames <- names(data)[2:10]
m <- dim(X)[2]
# setting up the prior
mu <- as.vector(rep(0,m))
Sigma <- 100 * solve(t(X)%*%X)
LogPostLogistic <- function(beta, y, X, mu, Sigma){
M <- length(beta)
# log the likelihood of Possion Distribution
logLik <- -sum(exp(X%*%beta)) + sum(y%*%(X%*%beta))
if (abs(logLik) == Inf){
logLik <- -20000
# Likelihood is not finite, stear the optimizer away from here!
# by Teacher's idea
}
# prior follows multi-normal distribution with
logPrior <- dmvnorm(beta, mu, Sigma, log = TRUE)
# cuz we logarithmize the likelihood and prior,
# posterior is the sum of them
return(logLik + logPrior)
}
initVal <- as.vector(rnorm(dim(X)[2]))
OptimResults <- optim(initVal,
LogPostLogistic,
y = y,
X = X,
mu = mu,
Sigma = Sigma,
method = c("BFGS"),
control = list(fnscale=-1),
hessian = TRUE)  # output hessian matrix
# Printing the results to the screen
postMode <- OptimResults$par
# Posterior covariance matrix is -inv(Hessian)
postCov <- -solve(OptimResults$hessian)
# Computing approximate standard deviations.
approxPostStd <- sqrt(diag(postCov))
# Naming the coefficient by covariates
names(postMode) <- covNames
names(approxPostStd) <- covNames
print('The posterior mode is:')
print(postMode)
print('The approximate posterior standard deviation is:')
print(approxPostStd)
set.seed(12345)
RWMSampler <- function(LogPostFunc, num, c,...){
# In random walk, all draws are from sample proposal
draws <- data.frame(matrix(nrow = num, ncol = 9))
colnames(draws) <- colnames(X)
draws[1,] <- mvrnorm(n = 1, postMode, c*postCov)
count <- 1
i <- 0
while(count<num) {
i <- i+1
theta.old <- as.numeric(draws[count,])
theta.new <- mvrnorm(n = 1, theta.old, c*postCov)
u <- runif(1,0,1)
# LogPostFunc is the distribution of theta/posterior we assume
left  <- LogPostFunc(theta.new,...)
right <- LogPostFunc(theta.old,...)
a <- min(1, exp(left-right))
if(u<a){
count <- count + 1
draws[count,] <- theta.new
}
}
cat("acceptance probability: ",num/i)
return(draws)
}
c <- 0.3
num <- 1000
RW <- RWMSampler(LogPostFunc = LogPostLogistic,
num = num,
c = c,
y = y, X = X, mu = postMode, Sigma = postCov)
colMeans(RW)
set.seed(12345)
RWMSampler <- function(LogPostFunc, num, c,...){
# In random walk, all draws are from sample proposal
draws <- data.frame(matrix(nrow = num, ncol = 9))
colnames(draws) <- colnames(X)
draws[1,] <- mvrnorm(n = 1, postMode, c*postCov)
count <- 1
i <- 0
while(count<num) {
i <- i+1
theta.old <- as.numeric(draws[count,])
theta.new <- mvrnorm(n = 1, theta.old, c*postCov)
u <- runif(1,0,1)
# LogPostFunc is the distribution of theta/posterior we assume
left  <- LogPostFunc(theta.new,...)
right <- LogPostFunc(theta.old,...)
a <- min(1, exp(left-right))
if(u<a){
count <- count + 1
draws[count,] <- theta.new
}
}
cat("acceptance probability: ",num/i,"\n")
return(draws)
}
c <- 0.3
num <- 1000
RW <- RWMSampler(LogPostFunc = LogPostLogistic,
num = num,
c = c,
y = y, X = X, mu = postMode, Sigma = postCov)
colMeans(RW)
t(mdl.2a$coefficients)
colnames(postMode)
postMode
names(postMode)
t(postMode)
RW[num,]
t <- t(mdl.2a$coefficients)
colnames(t) <- names(postMode)
results <- rbind(t, t(postMode),colMeans(RW) )
?kable_styling
t <- t(mdl.2a$coefficients)
colnames(t) <- names(postMode)
results <- rbind(t, t(postMode),colMeans(RW))
kable(results) %>%
kable_styling(latex_options="scale_down")
library(kableExtra)
t <- t(mdl.2a$coefficients)
colnames(t) <- names(postMode)
results <- rbind(t, t(postMode),colMeans(RW))
kable(results) %>%
kable_styling(latex_options="scale_down")
t <- t(mdl.2a$coefficients)
colnames(t) <- names(postMode)
results <- rbind(t, t(postMode),colMeans(RW))
results <- cbind(step = c("Q2a","Q2b","Q2c"))
kable(results) %>%
kable_styling(latex_options="scale_down")
t <- t(mdl.2a$coefficients)
colnames(t) <- names(postMode)
results <- rbind(t, t(postMode),colMeans(RW))
results <- cbind(step = c("Q2a","Q2b","Q2c"), results)
kable(results) %>%
kable_styling(latex_options="scale_down")
options(digits = 3)
t <- t(mdl.2a$coefficients)
colnames(t) <- names(postMode)
results <- rbind(t, t(postMode),colMeans(RW))
results <- cbind(step = c("Q2a","Q2b","Q2c"), results)
kable(results) %>%
kable_styling(latex_options="scale_down")
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE, out.width = "320px")
t <- t(mdl.2a$coefficients)
colnames(t) <- names(postMode)
results <- rbind(t, t(postMode),colMeans(RW))
results <- cbind(step = c("Q2a","Q2b","Q2c"), results)
results <- as.data.frame(results, digits = 4)
kable(results) %>%
kable_styling(latex_options="scale_down")
set.seed(12345)
RWMSampler <- function(LogPostFunc, num, c,...){
# In random walk, all draws are from sample proposal
draws <- data.frame(matrix(nrow = num, ncol = 9))
colnames(draws) <- colnames(X)
draws[1,] <- mvrnorm(n = 1, postMode, c*postCov)
count <- 1
i <- 0
while(count<num) {
i <- i+1
theta.old <- as.numeric(draws[count,])
theta.new <- mvrnorm(n = 1, theta.old, c*postCov)
u <- runif(1,0,1)
# LogPostFunc is the distribution of theta/posterior we assume
left  <- LogPostFunc(theta.new,...)
right <- LogPostFunc(theta.old,...)
a <- min(1, exp(left-right))
if(u<a){
count <- count + 1
draws[count,] <- theta.new
}
}
cat("acceptance probability: ",num/i,"\n")
return(draws)
}
c <- 0.3
num <- 100
RW <- RWMSampler(LogPostFunc = LogPostLogistic,
num = num,
c = c,
y = y, X = X, mu = postMode, Sigma = postCov)
colMeans(RW)
Index <- 1:num
data.2c <- cbind(RW, Index)
cnames <- colnames(data.2c)[1:9]
f <- function(cname){
ggplot(data.2c, aes_string(x = Index, y = cname)) +
geom_line() +
stat_smooth()
}
plot(arrangeGrob(grobs = lapply(cnames, f)))
set.seed(12345)
RWMSampler <- function(LogPostFunc, num, c,...){
# In random walk, all draws are from sample proposal
draws <- data.frame(matrix(nrow = num, ncol = 9))
colnames(draws) <- colnames(X)
draws[1,] <- mvrnorm(n = 1, postMode, c*postCov)
count <- 1
i <- 0
while(count<num) {
i <- i+1
theta.old <- as.numeric(draws[count,])
theta.new <- mvrnorm(n = 1, theta.old, c*postCov)
u <- runif(1,0,1)
# LogPostFunc is the distribution of theta/posterior we assume
left  <- LogPostFunc(theta.new,...)
right <- LogPostFunc(theta.old,...)
a <- min(1, exp(left-right))
if(u<a){
count <- count + 1
draws[count,] <- theta.new
}
}
cat("acceptance probability: ",num/i,"\n")
return(draws)
}
c <- 0.4
num <- 100
RW <- RWMSampler(LogPostFunc = LogPostLogistic,
num = num,
c = c,
y = y, X = X, mu = postMode, Sigma = postCov)
colMeans(RW)
Index <- 1:num
data.2c <- cbind(RW, Index)
cnames <- colnames(data.2c)[1:9]
f <- function(cname){
ggplot(data.2c, aes_string(x = Index, y = cname)) +
geom_line() +
stat_smooth()
}
plot(arrangeGrob(grobs = lapply(cnames, f)))
set.seed(12345)
RWMSampler <- function(LogPostFunc, num, c,...){
# In random walk, all draws are from sample proposal
draws <- data.frame(matrix(nrow = num, ncol = 9))
colnames(draws) <- colnames(X)
draws[1,] <- mvrnorm(n = 1, postMode, c*postCov)
count <- 1
i <- 0
while(count<num) {
i <- i+1
theta.old <- as.numeric(draws[count,])
theta.new <- mvrnorm(n = 1, theta.old, c*postCov)
u <- runif(1,0,1)
# LogPostFunc is the distribution of theta/posterior we assume
left  <- LogPostFunc(theta.new,...)
right <- LogPostFunc(theta.old,...)
a <- min(1, exp(left-right))
if(u<a){
count <- count + 1
draws[count,] <- theta.new
}
}
cat("acceptance probability: ",num/i,"\n")
return(draws)
}
c <- 0.4
num <- 500
RW <- RWMSampler(LogPostFunc = LogPostLogistic,
num = num,
c = c,
y = y, X = X, mu = postMode, Sigma = postCov)
colMeans(RW)
Index <- 1:num
data.2c <- cbind(RW, Index)
cnames <- colnames(data.2c)[1:9]
f <- function(cname){
ggplot(data.2c, aes_string(x = Index, y = cname)) +
geom_line() +
stat_smooth()
}
plot(arrangeGrob(grobs = lapply(cnames, f)))
set.seed(12345)
RWMSampler <- function(LogPostFunc, num, c,...){
# In random walk, all draws are from sample proposal
draws <- data.frame(matrix(nrow = num, ncol = 9))
colnames(draws) <- colnames(X)
draws[1,] <- mvrnorm(n = 1, postMode, c*postCov)
count <- 1
i <- 0
while(count<num) {
i <- i+1
theta.old <- as.numeric(draws[count,])
theta.new <- mvrnorm(n = 1, theta.old, c*postCov)
u <- runif(1,0,1)
# LogPostFunc is the distribution of theta/posterior we assume
left  <- LogPostFunc(theta.new,...)
right <- LogPostFunc(theta.old,...)
a <- min(1, exp(left-right))
if(u<a){
count <- count + 1
draws[count,] <- theta.new
}
}
cat("acceptance probability: ",num/i,"\n")
return(draws)
}
c <- 0.35
num <- 500
RW <- RWMSampler(LogPostFunc = LogPostLogistic,
num = num,
c = c,
y = y, X = X, mu = postMode, Sigma = postCov)
colMeans(RW)
Index <- 1:num
data.2c <- cbind(RW, Index)
cnames <- colnames(data.2c)[1:9]
f <- function(cname){
ggplot(data.2c, aes_string(x = Index, y = cname)) +
geom_line() +
stat_smooth()
}
plot(arrangeGrob(grobs = lapply(cnames, f)))
Index <- 1:num
data.2c <- cbind(RW, Index)
cnames <- colnames(data.2c)[1:9]
f <- function(cname){
ggplot(data.2c, aes_string(x = Index, y = cname)) +
geom_line() +
stat_smooth()
}
plot(arrangeGrob(grobs = lapply(cnames, f)))
f <- function(cname){
ggplot(data.2c, aes_string(x = cname)) +
geom_histogram(aes(y=..density..),
colour="black",
fill="white",
bins=30)+
geom_density(alpha=.2, colour = "blue", size=1)
}
plot(arrangeGrob(grobs = lapply(cnames, f)))
?arrangeGrob
data.frame(t(mdl.2a$coefficients),digits = 3)
format(t(mdl.2a$coefficients),3)
format(t(mdl.2a$coefficients),2)
format(t(mdl.2a$coefficients),1)
?format
specify_decimal(t, 3)
fixed(t,2)
format(t, nsmall=2)
format(mdl.2a$coefficients, nsmall=2)
format(444, nsmall=2)
options(digits = 7)
format(t, nsmall=2)
round(t,2)
round(results,2)
class(t)
t <- round(t(mdl.2a$coefficients), 3)
t
t <- round(t(mdl.2a$coefficients), 3)
colnames(t) <- names(postMode)
results <- rbind(t, rount(t(postMode),3),round(colMeans(RW),3))
t <- round(t(mdl.2a$coefficients), 3)
colnames(t) <- names(postMode)
results <- rbind(t, round(t(postMode),3),round(colMeans(RW),3))
results <- cbind(step = c("Q2a","Q2b","Q2c"), results)
kable(results) %>%
kable_styling(latex_options="scale_down")
